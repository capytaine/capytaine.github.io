<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Meshes &#8212; capytaine 2.3.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css?v=e9a64e30" />
    <script src="../_static/documentation_options.js?v=7906c0ec"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/proof.js?v=41e9dd12"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Floating body" href="body.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
    <script defer data-domain="capytaine.github.io" src="https://plausible.io/js/script.js"></script>
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  


  </head><body>
  

    <div class="document">
<div id="new-doc-warning-banner" style="width:100%; background-color:#ADD8E6; text-align: center;">This page is part of the documentation of the development version 2.3 of Capytaine.<br><a href="https://capytaine.github.io/stable/">Latest stable version is available here.</a></div>
    
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="meshes">
<h1>Meshes<a class="headerlink" href="#meshes" title="Link to this heading">¶</a></h1>
<section id="naming">
<h2>Naming<a class="headerlink" href="#naming" title="Link to this heading">¶</a></h2>
<p>Meshes in Capytaine have a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute.
It is optional and is mostly used for clearer logging and outputs.
A <code class="docutils literal notranslate"><span class="pre">name</span></code> optional argument can be provided to all methods below to initialize
a mesh or transform a mesh to set the name of the new mesh.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A mesh in Capytaine is merely a set of independent faces (triangles or quadrangles).
Connectivities are not required for the resolution.
Having a mesh that is not watertight, with small gaps between the faces or a
few missing faces, does not lead to qualitatively different results.</p>
</div>
</section>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Link to this heading">¶</a></h2>
<section id="importing-with-included-meshmagick-readers">
<h3>Importing with included Meshmagick readers<a class="headerlink" href="#importing-with-included-meshmagick-readers" title="Link to this heading">¶</a></h3>
<p>To load an existing mesh file, use the following syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">capytaine</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cpt</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s1">&#39;path/to/mesh.dat&#39;</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="s1">&#39;nemoh&#39;</span><span class="p">)</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">FloatingBody</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example uses Nemoh’s mesh format, as defined e.g. on page 19 of <a class="reference external" href="https://gitlab.com/api/v4/projects/41313230/packages/generic/nemoh/v3.0.1/Nemoh_Manual_v3.0.1.pdf">Nemoh v3.0.1 manual</a>.</p>
<p>Thanks to inclusion of code from <a class="reference external" href="https://github.com/lheea/meshmagick/">Meshmagick</a>,
numerous other mesh format can be imported.
The file format can be given with the <code class="code docutils literal notranslate"><span class="pre">file_format</span></code> optional argument.
If no format is given, the code will try to infer it from the file extension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s1">&#39;path/to/mesh.msh&#39;</span><span class="p">)</span>  <span class="c1"># gmsh file</span>
</pre></div>
</div>
<p>The formats currently supported in reading are listed in the following table (adapted from the documentation of Meshmagick).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>File
extension</p></th>
<th class="head"><p>Software</p></th>
<th class="head"><p>Keywords</p></th>
<th class="head"><p>Extra features</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.mar</p></td>
<td><p>NEMOH <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>nemoh, mar</p></td>
<td><p>Symmetries</p></td>
</tr>
<tr class="row-odd"><td><p>.nem</p></td>
<td><p>NEMOH <a class="footnote-reference brackets" href="#f1" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>nemoh_mesh, nem</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.gdf</p></td>
<td><p>WAMIT <a class="footnote-reference brackets" href="#f2" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>wamit, gdf</p></td>
<td><p>Symmetries</p></td>
</tr>
<tr class="row-odd"><td><p>.inp</p></td>
<td><p>DIODORE <a class="footnote-reference brackets" href="#f3" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>diodore-inp, inp</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.DAT</p></td>
<td><p>DIODORE <a class="footnote-reference brackets" href="#f3" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>diodore-dat</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>.pnl</p></td>
<td><p>HAMS</p></td>
<td><p>pnl, hams</p></td>
<td><p>Symmetries</p></td>
</tr>
<tr class="row-even"><td><p>.hst</p></td>
<td><p>HYDROSTAR <a class="footnote-reference brackets" href="#f4" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td>
<td><p>hydrostar, hst</p></td>
<td><p>Symmetries</p></td>
</tr>
<tr class="row-odd"><td><p>.nat</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>natural, nat</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.msh</p></td>
<td><p>GMSH <a class="footnote-reference brackets" href="#f5" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
<td><p>gmsh, msh</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>.rad</p></td>
<td><p>RADIOSS</p></td>
<td><p>rad, radioss</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.stl</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>stl</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>.vtu</p></td>
<td><p>PARAVIEW <a class="footnote-reference brackets" href="#f6" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
<td><p>vtu</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.vtp</p></td>
<td><p>PARAVIEW <a class="footnote-reference brackets" href="#f6" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
<td><p>vtp</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>.vtk</p></td>
<td><p>PARAVIEW <a class="footnote-reference brackets" href="#f6" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
<td><p>paraview-legacy, vtk</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>.tec</p></td>
<td><p>TECPLOT <a class="footnote-reference brackets" href="#f7" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p></td>
<td><p>tecplot, tec</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>.med</p></td>
<td><p>SALOME <a class="footnote-reference brackets" href="#f8" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p></td>
<td><p>med, salome</p></td>
<td></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>)</span>
<p>NEMOH is an open source BEM Software for seakeeping developed at
Ecole Centrale de Nantes (LHEEA)</p>
</aside>
<aside class="footnote brackets" id="f2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>WAMIT is a BEM Software for seakeeping developed by WAMIT, Inc.</p>
</aside>
<aside class="footnote brackets" id="f3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>DIODORE is a BEM Software for seakeeping developed by PRINCIPIA</p>
</aside>
<aside class="footnote brackets" id="f4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p>HYDROSTAR is a BEM Software for seakeeping developed by
BUREAU VERITAS</p>
</aside>
<aside class="footnote brackets" id="f5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>GMSH is an open source meshing software developed by C. Geuzaine
and J.-F. Remacle. Version 4 of the file format requires meshio
be installed independently.</p>
</aside>
<aside class="footnote brackets" id="f6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id8">1</a>,<a role="doc-backlink" href="#id9">2</a>,<a role="doc-backlink" href="#id10">3</a>)</span>
<p>PARAVIEW is an open source visualization software developed by
Kitware</p>
</aside>
<aside class="footnote brackets" id="f7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">7</a><span class="fn-bracket">]</span></span>
<p>TECPLOT is a visualization software developed by Tecplot</p>
</aside>
<aside class="footnote brackets" id="f8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">8</a><span class="fn-bracket">]</span></span>
<p>SALOME-MECA is an open source software for computational mechanics
developed by EDF-R&amp;D</p>
</aside>
</aside>
<p>Not all metadata is taken into account when reading the mesh file.
For instance, the body symmetry is taken into account only for the <code class="docutils literal notranslate"><span class="pre">.mar</span></code>, <code class="docutils literal notranslate"><span class="pre">.pnl</span></code>, <code class="docutils literal notranslate"><span class="pre">.gdf</span></code> and <code class="docutils literal notranslate"><span class="pre">.hst</span></code> file formats.
Feel free to open an issue on Github to suggest improvements.</p>
</section>
<section id="importing-with-meshio">
<h3>Importing with Meshio<a class="headerlink" href="#importing-with-meshio" title="Link to this heading">¶</a></h3>
<p>Mesh can also be imported using the <a class="reference external" href="https://pypi.org/project/meshio/">meshio</a>
library. Unlike the Meshmagick mesh readers mentioned above, this library is
not packaged with Capytaine and need to be installed independently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">meshio</span>
</pre></div>
</div>
<p>The <cite>meshio</cite> mesh object can converted to Capytaine’s mesh
format with the <a class="reference internal" href="../developer_manual/api/capytaine.io.meshio.html#capytaine.io.meshio.load_from_meshio" title="capytaine.io.meshio.load_from_meshio"><code class="xref py py-func docutils literal notranslate"><span class="pre">load_from_meshio()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">capytaine.io.meshio</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_from_meshio</span>
<span class="n">cpt_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_from_meshio</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;My mesh&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This features allows to use <a class="reference external" href="https://pypi.org/project/pygmsh/">pygmsh</a> to
generate the mesh, since this library returns mesh in the same format as meshio.
Below is an example of a mesh generation with <cite>pygmsh</cite> (which also needs to be
installed independently):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygmsh</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mf">1e-2</span>
<span class="n">T1</span> <span class="o">=</span> <span class="mf">0.16</span>
<span class="n">T2</span> <span class="o">=</span> <span class="mf">0.37</span>
<span class="n">r1</span> <span class="o">=</span> <span class="mf">0.88</span>
<span class="n">r2</span> <span class="o">=</span> <span class="mf">0.35</span>
<span class="k">with</span> <span class="n">pygmsh</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">Geometry</span><span class="p">()</span> <span class="k">as</span> <span class="n">geom</span><span class="p">:</span>
    <span class="n">cyl</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">add_cylinder</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">T1</span><span class="p">],</span>  <span class="n">r1</span><span class="p">)</span>
    <span class="n">cone</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">add_cone</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">T1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">T2</span><span class="p">],</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
    <span class="n">geom</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">cyl</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">])</span>
    <span class="n">geom</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">cone</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">])</span>
    <span class="n">geom</span><span class="o">.</span><span class="n">boolean_union</span><span class="p">([</span><span class="n">cyl</span><span class="p">,</span> <span class="n">cone</span><span class="p">])</span>
    <span class="n">gmsh_mesh</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">generate_mesh</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">gmsh_mesh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_pygmsh_mesh&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="predefined-simple-shapes">
<h3>Predefined simple shapes<a class="headerlink" href="#predefined-simple-shapes" title="Link to this heading">¶</a></h3>
<p>Capytaine include mesh generators for a few simple shapes. They are mostly
meant for teaching (they are extensively used in the examples of this
documentation) as well as for testing.
The most useful ones are
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.spheres.html#capytaine.meshes.predefined.spheres.mesh_sphere" title="capytaine.meshes.predefined.spheres.mesh_sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_sphere()</span></code></a>,
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.cylinders.html#capytaine.meshes.predefined.cylinders.mesh_vertical_cylinder" title="capytaine.meshes.predefined.cylinders.mesh_vertical_cylinder"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_vertical_cylinder()</span></code></a>,
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.cylinders.html#capytaine.meshes.predefined.cylinders.mesh_horizontal_cylinder" title="capytaine.meshes.predefined.cylinders.mesh_horizontal_cylinder"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_horizontal_cylinder()</span></code></a>,
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.rectangles.html#capytaine.meshes.predefined.rectangles.mesh_parallelepiped" title="capytaine.meshes.predefined.rectangles.mesh_parallelepiped"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_parallelepiped()</span></code></a>.
Some applications may also make use of flat shapes
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.cylinders.html#capytaine.meshes.predefined.cylinders.mesh_disk" title="capytaine.meshes.predefined.cylinders.mesh_disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_disk()</span></code></a> and
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.predefined.rectangles.html#capytaine.meshes.predefined.rectangles.mesh_rectangle" title="capytaine.meshes.predefined.rectangles.mesh_rectangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_rectangle()</span></code></a>.
Refer to their documentation for details about the parameters they accepts.</p>
<p>Since version 2.1, their resolution can be set by the <code class="docutils literal notranslate"><span class="pre">faces_max_radius</span></code>
parameter which specifies the maximal size of a face in the mesh.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are several ways to measure the size of a face and the resolution of a mesh.
In Capytaine, the size of faces is usually quantified with the <em>radius</em> of the face, that is the maximal distance between the center of the face and its vertices.
The resolution of a mesh is estimated as the maximal radius among all the faces in the mesh, that is the radius of the biggest face.</p>
</div>
</section>
<section id="creating-from-scratch">
<h3>Creating from scratch<a class="headerlink" href="#creating-from-scratch" title="Link to this heading">¶</a></h3>
<p>Alternatively, a mesh can be defined by giving a list of vertices and faces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=...</span><span class="p">,</span> <span class="n">faces</span><span class="o">=...</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_mesh&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The vertices are expected to be provided as a Numpy array of floats with shape <code class="docutils literal notranslate"><span class="pre">(nb_vertices,</span> <span class="pre">3)</span></code>.
The faces are provided as a Numpy array of ints with shape <code class="docutils literal notranslate"><span class="pre">(nb_faces,</span> <span class="pre">4)</span></code>, such that the four integers on a line are the indices of the vertices composing that face:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="n">single_face_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The ordering of the vertices define the direction of the normal vector, using
normal right rotation. In other words, the normal vector is towards you if you
see the vertices as being in counterclockwise order. In the above example, the
normal vector is going up.</p>
<p>Triangular faces are supported as quadrilateral faces with the same vertex
repeated twice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">single_triangle_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
</pre></div>
</div>
</section>
<section id="creating-a-symmetric-mesh">
<h3>Creating a symmetric mesh<a class="headerlink" href="#creating-a-symmetric-mesh" title="Link to this heading">¶</a></h3>
<p>Several mesh symmetries can be used by Capytaine to speed up the computation.
The most useful one is the vertical plane symmetry.
A mesh with such a symmetry is stored by Capytaine with the
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.symmetric.html#capytaine.meshes.symmetric.ReflectionSymmetricMesh" title="capytaine.meshes.symmetric.ReflectionSymmetricMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReflectionSymmetricMesh</span></code></a> class.
It is defined with an other mesh of the half and a plane (and optionally a name
like the usual meshes):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">half_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">ReflectionSymmetricMesh</span><span class="p">(</span><span class="n">half_mesh</span><span class="p">,</span> <span class="n">cpt</span><span class="o">.</span><span class="n">xOz_Plane</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my full mesh&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Two vertical plane symmetries can be nested to be used by Capytaine (assuming
that the two planes are orthogonal):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">quarter_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">half_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">ReflectionSymmetricMesh</span><span class="p">(</span><span class="n">half_mesh</span><span class="p">,</span> <span class="n">cpt</span><span class="o">.</span><span class="n">yOz_Plane</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">ReflectionSymmetricMesh</span><span class="p">(</span><span class="n">half_mesh</span><span class="p">,</span> <span class="n">cpt</span><span class="o">.</span><span class="n">xOz_Plane</span><span class="p">)</span>
</pre></div>
</div>
<p>All the method defined afterwards in this documentation should be applicable
for <code class="docutils literal notranslate"><span class="pre">ReflectionSymmetricMesh</span></code> as well as for standard <code class="docutils literal notranslate"><span class="pre">Mesh</span></code>.</p>
<p>You can consider using the <code class="docutils literal notranslate"><span class="pre">clipped</span></code> method discussed below to create a symmetric mesh:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">half_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">clipped</span><span class="p">(</span><span class="n">plane</span><span class="o">=</span><span class="n">cpt</span><span class="o">.</span><span class="n">xOz_Plane</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">ReflectionSymmetricMesh</span><span class="p">(</span><span class="n">half_mesh</span><span class="p">,</span> <span class="n">cpt</span><span class="o">.</span><span class="n">xOz_Plane</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="display">
<h2>Display<a class="headerlink" href="#display" title="Link to this heading">¶</a></h2>
<p>Use the <code class="code docutils literal notranslate"><span class="pre">show</span></code> method to display the mesh in 3D using VTK (if installed)
with the <a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.show" title="capytaine.meshes.meshes.Mesh.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>or with Matplotlib (if installed) with
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.show_matplotlib" title="capytaine.meshes.meshes.Mesh.show_matplotlib"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show_matplotlib()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">show_matplotlib</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="geometric-transformations">
<h2>Geometric transformations<a class="headerlink" href="#geometric-transformations" title="Link to this heading">¶</a></h2>
<p>Several functions are available to transform existing meshes.</p>
<p>Below is a list of most of the available methods.
All of them can be applied to both meshes or to floating bodies, in which case
the degrees of freedom will also be transformed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># TRANSLATIONS</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">translated_x</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">translated_y</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">translated_z</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">translated</span><span class="p">([</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>

<span class="c1"># Translation such that point_a would become equal to point_b</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">translated_point_to_point</span><span class="p">(</span><span class="n">point_a</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">point_b</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="c1"># ROTATIONS</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">rotated_x</span><span class="p">(</span><span class="mf">3.14</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Rotation of pi/5 around the Ox axis</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">rotated_y</span><span class="p">(</span><span class="mf">3.14</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Rotation of pi/5 around the Oy axis</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">rotated_z</span><span class="p">(</span><span class="mf">3.14</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Rotation of pi/5 around the Oz axis</span>

<span class="c1"># Rotation of pi/5 around an arbitrary axis.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">capytaine</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axis</span>
<span class="n">my_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">point</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">rotated</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">my_axis</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">3.14</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Rotation around a point such that vec1 becomes aligned with vec2</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">rotated_around_center_to_align_vector</span><span class="p">(</span>
    <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">vec1</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
    <span class="n">vec2</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># REFLECTIONS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">capytaine</span><span class="w"> </span><span class="kn">import</span> <span class="n">Plane</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">mirrored</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">normal</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">point</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</pre></div>
</div>
<p>All the above methods can also be applied to <a class="reference internal" href="../developer_manual/api/capytaine.meshes.geometry.html#capytaine.meshes.geometry.Plane" title="capytaine.meshes.geometry.Plane"><code class="xref py py-class docutils literal notranslate"><span class="pre">Plane</span></code></a>
and <a class="reference internal" href="../developer_manual/api/capytaine.meshes.geometry.html#capytaine.meshes.geometry.Axis" title="capytaine.meshes.geometry.Axis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Axis</span></code></a> objects.</p>
<p>Meshes can also be merged together with the <code class="code docutils literal notranslate"><span class="pre">+</span></code> operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">larger_mesh</span> <span class="o">=</span> <span class="n">mesh_1</span> <span class="o">+</span> <span class="n">mesh_2</span>
</pre></div>
</div>
<p>Finally, meshes can be clipped with a <a class="reference internal" href="../developer_manual/api/capytaine.meshes.geometry.html#capytaine.meshes.geometry.Plane" title="capytaine.meshes.geometry.Plane"><code class="xref py py-class docutils literal notranslate"><span class="pre">Plane</span></code></a>.
The plane is defined by a point belonging to it and a normal vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xOy_Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">clipped_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">clipped</span><span class="p">(</span><span class="n">xOy_Plane</span><span class="p">)</span>
</pre></div>
</div>
<p>Beware that the orientation of the normal vector of the <code class="code docutils literal notranslate"><span class="pre">Plane</span></code> will
determine which part of the mesh will be returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">higher_part</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">clipped</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">lower_part</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">clipped</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="c1"># mesh = lower_part + higher_part</span>
</pre></div>
</div>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">immersed_part()</span></code> will clip the body with respect to two
horizontal planes at <span class="math notranslate nohighlight">\(z=0\)</span> and <span class="math notranslate nohighlight">\(z=-h\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clipped_body</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">immersed_part</span><span class="p">(</span><span class="n">water_depth</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most transformation methods exist in two versions:</p>
<ul class="simple">
<li><p>one, named as a infinitive verb (<cite>translate</cite>, <cite>rotate</cite>, <cite>clip</cite>,
<cite>keep_immersed_part</cite>, …), is an in-place transformation;</p></li>
<li><p>the other, named as a past participle (<cite>translated</cite>, <cite>rotated</cite>,
<cite>clipped</cite>, <cite>immersed_part</cite>, …), is the same transformation but
returning a new object.</p></li>
</ul>
<p>In most cases, performance is not significant and the method returning a
new object should be preferred. In-place transformation are currently kept
for backward compatibility, but they make the code significantly more
complicated and their removal might be considered in the future.</p>
</div>
</section>
<section id="extracting-or-generating-a-lid">
<h2>Extracting or generating a lid<a class="headerlink" href="#extracting-or-generating-a-lid" title="Link to this heading">¶</a></h2>
<p>If you loaded a mesh file already containing a lid on the <span class="math notranslate nohighlight">\(z=0\)</span> plane,
the hull and the lid can be split with the
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.extract_lid" title="capytaine.meshes.meshes.Mesh.extract_lid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_lid()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">full_mesh</span> <span class="o">=</span> <span class="n">cpt</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">hull_mesh</span><span class="p">,</span> <span class="n">lid_mesh</span> <span class="o">=</span> <span class="n">full_mesh</span><span class="o">.</span><span class="n">extract_lid</span><span class="p">()</span>
</pre></div>
</div>
<p>If your mesh does not have a lid, and you’d like to have irregular frequencies
removal, you can generate a lid using
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.generate_lid" title="capytaine.meshes.meshes.Mesh.generate_lid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_lid()</span></code></a> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lid_mesh</span> <span class="o">=</span> <span class="n">hull_mesh</span><span class="o">.</span><span class="n">generate_lid</span><span class="p">()</span>
</pre></div>
</div>
<p>The mesh is generated on the free surface by default.
Since support for panels on the free surface is still experimental, it might be
more robust (but less efficient) to define a lid slightly below the free surface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lid_mesh</span> <span class="o">=</span> <span class="n">hull_mesh</span><span class="o">.</span><span class="n">generate_lid</span><span class="p">(</span><span class="n">z</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>The lower the lid, the more robust the computation, but also the less
irregular frequencies are removed. The method
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.lowest_lid_position" title="capytaine.meshes.meshes.Mesh.lowest_lid_position"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lowest_lid_position()</span></code></a> estimates the lowest
position such that all irregular frequencies below a given frequency are removed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lid_mesh</span> <span class="o">=</span> <span class="n">hull_mesh</span><span class="o">.</span><span class="n">generate_lid</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">hull_mesh</span><span class="o">.</span><span class="n">lowest_lid_position</span><span class="p">(</span><span class="n">omega_max</span><span class="o">=</span><span class="mf">10.0</span><span class="p">))</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.extract_lid" title="capytaine.meshes.meshes.Mesh.extract_lid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_lid()</span></code></a> also accepts an
optional argument <code class="docutils literal notranslate"><span class="pre">faces_max_radius</span></code> to set the resolution of the lid. By
default, the mean resolution of the hull mesh is used.</p>
<p>See <a class="reference internal" href="body.html"><span class="doc">Floating body</span></a> for detail on how to assign a lid mesh when defining a floating
body.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The lid does not need neither to cover the whole interior free surface, nor
to be connected with the hull mesh. The lid automatically generated by
<a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.extract_lid" title="capytaine.meshes.meshes.Mesh.extract_lid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_lid()</span></code></a> typically does not.
Nonetheless, the more interior free surface is covered, the more efficiently
the irregular frequencies will be removed.</p>
</div>
</section>
<section id="defining-an-integration-quadrature">
<h2>Defining an integration quadrature<a class="headerlink" href="#defining-an-integration-quadrature" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Quadratures are an advanced feature meant to experiment with numerical schemes.
The best compromise between precision and performance is often not to bother
with it and keep the default integration scheme.</p>
</div>
<p>During the resolution of the BEM problem, the Green function has to be
integrated on each panel of the mesh. Parts of the Green function (such as the
<span class="math notranslate nohighlight">\(1/r\)</span> Rankine terms) are integrated using an exact analytical expression
for the integral. Other parts of the Green function rely on numerical
integration. By default, this numerical integration is done by taking the value
at the center of the panel and multiplying by its area. For a more accurate
intagration, an higher order quadrature can be defined.</p>
<p>To define a quadrature scheme for a mesh, run the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">compute_quadrature</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;Gauss-Legendre 2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The quadrature data can then be accessed at:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">quadrature_points</span>
</pre></div>
</div>
<p>and will be used automatically when needed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Transformations of the mesh (merging, clipping, …) may reset the quadrature.
Compute it only on your final mesh.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Quadratures schemes have been designed with quadrilateral panels.
They work on triangular panels, but might not be as optimal then.</p>
</div>
<p>Alternatively, the <a class="reference internal" href="../developer_manual/api/capytaine.meshes.meshes.html#capytaine.meshes.meshes.Mesh.compute_quadrature" title="capytaine.meshes.meshes.Mesh.compute_quadrature"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_quadrature()</span></code></a>
also accepts methods from the <cite>Quadpy</cite> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">quadpy</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">compute_quadrature</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">quadpy</span><span class="o">.</span><span class="n">c2</span><span class="o">.</span><span class="n">get_good_scheme</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">capytaine</a></h1>



<p class="blurb">a Python-based linear potential flow BEM solver</p>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installation for users</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="body.html">Floating body</a></li>
<li class="toctree-l2"><a class="reference internal" href="hydrostatics.html">Hydrostatics</a></li>
<li class="toctree-l2"><a class="reference internal" href="problem_setup.html">Setting up a problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="resolution.html">Resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="outputs.html">Outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="post_pro.html">Post-processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="conventions.html">Conventions and differences to other codes</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Example scripts</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer_manual/index.html">Developer manual</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theory_manual/index.html">Theory manual</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">User manual</a><ul>
      <li>Previous: <a href="tutorial.html" title="previous chapter">Tutorial</a></li>
      <li>Next: <a href="body.html" title="next chapter">Floating body</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Matthieu Ancellin.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/user_manual/mesh.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>